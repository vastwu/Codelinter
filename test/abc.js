// Generated by CoffeeScript 1.10.0
var DEFAULT_CONFIG, LogExportor, Path, SOCKET_PORT, SocketManager, copy, fs, http, io, logExportors, manageInstance, redis;

function play() {
  var a = 'a';
  switch (a) {
  case 'a':
    return 2;
  case 'b':
    return 3;
  default:
    return 1;
  }
}


fs = require('fs');

http = require('http');

redis = require('redis');

Path = require('path');

LogExportor = require('./LogExportor');

SOCKET_PORT = 3000;

logExportors = {};

DEFAULT_CONFIG = {
  receiving: true,
  appCode: '*',
  filter: ''
};

copy = function (source) {
  var k, r, v;
  r = {};
  for (k in source) {
    v = source[k];
    if (typeof v === 'object') {
      r[k] = copy(v);
    } else {
      r[k] = v;
    }
  }
  return r;
};


/*
client = redis.createClient 6379,'127.0.0.1', {}

client.on "error",  (err) ->
  console.log "Error " + err
 */

io = null;

SocketManager = function (port) {
  var configs, self, socketServer;
  self = this;
  socketServer = http.createServer();
  io = require('socket.io')(socketServer);
  io.on('connection', function (socket) {
    console.log('connected!!!!!!!');
    socket.on('event', function (data) {
      return console.log('--------------------!!!!!!!!!!');
    });
    socket.on('config', function (data) {
      return self.setConfig(socket, data);
    });
    socket.on('disconnect', function () {
      return console.log('--------------------lost');
    });
    return socket.emit('event', 'welcome');
  });
  socketServer.listen(port);
  console.log("--socket run on " + port);
  configs = {};
  this.setConfig = function (socket, data) {
    var err, error;
    console.log('set config', data);
    if (data.filter) {
      try {
        data.filterReg = new RegExp(data.filter);
      } catch (error) {
        err = error;
        socket.emit('error', 'parse config.filter Error!');
      }
    }
    socket.$config = data;
    return configs[socket.id] = data;
  };
  this.getConfig = function (socket) {
    return configs[socket.id] || DEFAULT_CONFIG;
  };
  this.close = function () {
    var clients;
    io.close();
    return clients = [];
  };
  this.isSending = function (socket, args) {
    var config;
    config = this.getConfig(socket);
    if (config.receiving !== true) {
      return false;
    }
    if (config.appCode !== '*' && config.appCode !== args.appCode) {
      return false;
    }
    if (config.filterReg && config.filterReg.test(args.content) === false) {
      return false;
    }
    return true;
  };
  debugger;
  this.boardcast = function (evt, args) {
    var id, results, socket, sockets;
    self = this;
    sockets = io.sockets.sockets;
    results = [];
    for (id in sockets) {
      socket = sockets[id];
      if (this.isSending(socket, args) === true) {
        results.push(socket.emit(evt, args));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };
};

manageInstance = null;

module.exports = function (req, res) {
  var args, exportor, filePath, html, item, log, logs, today, unique;
  switch (req.url.pathname) {
    case '/status':
      return res.json({
        status: 200,
        enable: manageInstance ? '1' : '0',
        socketPort: SOCKET_PORT,
        defaultConfig: DEFAULT_CONFIG
      });
    case '/start':
      if (!manageInstance) {
        manageInstance = new SocketManager(SOCKET_PORT);
        res.json({
          status: 200,
          socketPort: SOCKET_PORT
        });
      } else {
        res.json({
          status: 500,
          reason: "socket is listening " + SOCKET_PORT,
          socketPort: SOCKET_PORT
        });
      }
      break;
    case '/stop':
      manageInstance.close();
      manageInstance = null;
      res.end('ok');
      break;
    case '/send':
      res.end('');
      if (!manageInstance) {
        return;
      }
      args = copy(req.url.query);
      args.ua = req.headers['user-agent'] || '';
      args.host = req.headers['host'] || '';
      args.cookie = req.headers.cookie || '';
      args.date = Date.now();
      manageInstance.boardcast('log', args);
      return;
      if (!appCode) {
        throw new Error('missing app code');
      }
      delete query.code;
      exportor = logExportors[appCode];
      if (!exportor) {
        exportor = logExportors[appCode] = new LogExportor(appCode);
        exportor.autoFlush(true);
      }
      today = new Date();
      log = {
        query: query,
        unique: query.unique || void 0,
        ua: ua,
        cookie: req.headers.cookie,
        host: host,
        date: today.getTime()
      };
      unique = query.unique;
      delete query.unique;
      exportor.push(log, unique);
      log._waiting = exportor.length;
      return res.json(log);
    case '/index':
      filePath = "lib/client/report/index.html";
      html = fs.readFileSync(filePath, 'utf-8');
      return res.end(html);
    case '/get':
      filePath = "logs/app.3.20160114";
      logs = fs.readFileSync(filePath, 'utf-8');
      logs = logs.split('\n');
      logs = (function () {
        var i, len, results;
        results = [];
        for (i = 0, len = logs.length; i < len; i++) {
          item = logs[i];
          if (item) {
            results.push(JSON.parse(item));
          }
        }
        return results;
      })();
      return res.json({
        status: 0,
        result: logs
      });
  }
};
